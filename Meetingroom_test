from pulp import *
import random
import numpy as np
from sklearn.ensemble import RandomForestRegressor

# -------------------------------
# ข้อมูลกลุ่มและห้อง
# -------------------------------
groups = [
    {
         "id": "A",
         "main_start": 10, "main_end": 12,
         "alt_start": 13, "alt_end": 15,
         "priority": 5, "order": 1, "size": 4
    },
    {
         "id": "B",
         "main_start": 11, "main_end": 13,
         "alt_start": 15, "alt_end": 17,
         "priority": 3, "order": 2, "size": 2
    },
    {
         "id": "C",
         "main_start": 13, "main_end": 14,
         "alt_start": 15, "alt_end": 17,
         "priority": 4, "order": 3, "size": 3
    },
    {
         "id": "D",
         "main_start": 11, "main_end": 14,
         "alt_start": 15, "alt_end": 17,
         "priority": 3, "order": 4, "size": 3
    }
]

rooms = [
    {"id": "R1", "capacity": 4},
    {"id": "R2", "capacity": 6}
]

# -------------------------------
# สร้างข้อมูลเทรน AI
# -------------------------------
def generate_training_data(num_samples=1000):
    data = []
    labels = []
    for _ in range(num_samples):
        size = random.randint(1, 6)
        priority = random.randint(1, 5)
        duration = random.randint(1, 3)
        start = random.randint(8, 17 - duration)
        end = start + duration
        hour = start
        room_capacity = random.choice([4, 6])

        # สมการจำลอง demand
        demand = (
            0.5 * priority +
            0.2 * size +
            0.1 * (room_capacity - size) +
            0.1 * (12 - abs(hour - 12))
        ) + random.uniform(-0.5, 0.5)

        data.append([size, priority, start, end, room_capacity])
        labels.append(demand)

    return np.array(data), np.array(labels)

X_train, y_train = generate_training_data()
rf_model = RandomForestRegressor()
rf_model.fit(X_train, y_train)

# -------------------------------
# คำนวณ demand score
# -------------------------------
demand_scores = {}
for g in groups:
    for r in rooms:
        for slot in ["main", "alt"]:
            start = g[f"{slot}_start"]
            end = g[f"{slot}_end"]
            features = np.array([[g["size"], g["priority"], start, end, r["capacity"]]])
            demand = rf_model.predict(features)[0]
            demand_scores[(g["id"], r["id"], slot)] = demand

# -------------------------------
# Optimization model
# -------------------------------
model = LpProblem("Room_Scheduling", LpMaximize)

# ตัวแปรตัดสินใจ
x = {}
for g in groups:
    for r in rooms:
        for slot in ["main", "alt"]:
            key = (g["id"], r["id"], slot)
            x[key] = LpVariable(f"x_{g['id']}_{r['id']}_{slot}", cat=LpBinary)

# Objective: maximize priority
model += lpSum([g["priority"] * x[(g["id"], r["id"], slot)]
            for g in groups for r in rooms for slot in ["main", "alt"]])

# Constraint 1: เลือกได้แค่ช่วงเดียวและห้องเดียว
for g in groups:
    model += lpSum([x[(g["id"], r["id'], slot)]
                for r in rooms for slot in ["main", "alt"]]) <= 1

# Constraint 2: ความจุห้องต้องพอ
for g in groups:
    for r in rooms:
        for slot in ["main", "alt"]:
            if g["size"] > r["capacity"]:
                model += x[(g["id"], r["id"], slot)] == 0

# Constraint 3: ห้ามเวลาชนกันในห้องเดียวกัน
for i in range(len(groups)):
    for j in range(i + 1, len(groups)):
        g1, g2 = groups[i], groups[j]
        for r in rooms:
            for s1 in ["main", "alt"]:
                for s2 in ["main", "alt"]:
                    t1_start, t1_end = g1[f"{s1}_start"], g1[f"{s1}_end"]
                    t2_start, t2_end = g2[f"{s2}_start"], g2[f"{s2}_end"]
                    if not (t1_end <= t2_start or t2_end <= t1_start):
                        model += x[(g1["id"], r["id"], s1)] + x[(g2["id"], r["id"], s2)] <= 1

# -------------------------------
# Solve
# -------------------------------
model.solve()

print("\n=== ผลการจัดสรรห้อง ===")
for g in groups:
    for r in rooms:
        for slot in ["main", "alt"]:
            if x[(g["id"], r["id"], slot)].value() == 1:
                start = g[f"{slot}_start"]
                end = g[f"{slot}_end"]
                score = demand_scores[(g["id"], r["id"], slot)]
                print(f"กลุ่ม {g['id']} ได้ใช้ห้อง {r['id']} ช่วง [{start}–{end}] (score={score:.2f})")

# -------------------------------
# วิเคราะห์ความหนาแน่นและคำแนะนำ
# -------------------------------
# นับจำนวนกลุ่มที่ต้องการต่อชั่วโมง
time_demand = {}
for g in groups:
    for slot in ["main", "alt"]:
        start, end = g[f"{slot}_start"], g[f"{slot}_end"]
        for t in range(start, end):
            time_demand[t] = time_demand.get(t, 0) + 1

print("\n=== ความหนาแน่นของการจอง (per hour) ===")
for hour in sorted(time_demand.keys()):
    print(f"ชั่วโมง {hour}: มีกลุ่ม {time_demand[hour]} กลุ่มที่ต้องการ")

# หาช่วงเวลาที่ว่างที่สุด
min_demand = min(time_demand.values())
free_hours = [h for h, d in time_demand.items() if d == min_demand]
print("\n=== ช่วงเวลาที่ว่างที่สุด ===")
print(f"ช่วงเวลา {free_hours} (มีเพียง {min_demand} กลุ่ม)")

# คำแนะนำเวลาที่เหมาะสม
print("\n=== คำแนะนำเวลาที่เหมาะสมสำหรับแต่ละกลุ่ม ===")
for g in groups:
    best_slot = None
    best_score = -1
    for slot in ["main", "alt"]:
        start, end = g[f"{slot}_start"], g[f"{slot}_end"]
        score = demand_scores[(g["id"], rooms[0]["id"], slot)]  # อิงห้องแรกเป็นตัวแทน
        # ถ้าช่วงนี้ไม่ใช่ peak (<= 2 กลุ่ม/ชั่วโมง) และได้ score สูง → เลือก
        if all(time_demand[t] <= 2 for t in range(start, end)) and score > best_score:
            best_score = score
            best_slot = (start, end)
    if best_slot:
        print(f"กลุ่ม {g['id']} ควรใช้ช่วง {best_slot} (score={best_score:.2f})")
